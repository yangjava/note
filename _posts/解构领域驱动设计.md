# 解构领域驱动设计

# [解构领域驱动设计（一）：为什么DDD能够解决软件复杂性](https://www.cnblogs.com/baihmpgy/p/10259264.html)

1 为什么我要研究领域驱动设计

1.1 设计方法各样且代码无法反映设计

我大概从2017年10月份开始研究DDD，当时在一家物流信息化的公司任职架构师，研究DDD的初衷在于为团队寻找一种软件设计的方法论。作为架构师，经常参与设计评审，包括：需求评审、设计评审、代码评审。在评审过程中，有一点感受非常深，就是评审过程非常痛苦且几乎没有效率和成果。让我痛苦的地方有：

- 每一个系统分析师都是基于自己的方式来进行设计功能，有的用类图、有的基于流程图，有的详细、有的粗放，更麻烦的是，大家对业务背景的理解程度完全不同，认知不同，沟通低效，很难找出设计的不合理性。
- 评审代码时，我几乎很难将其与设计对应起来，看设计我已经够痛苦了，还要被这些代码再虐待一遍，实在痛苦至极，这样的代码评审也就变成了代码规范性、代码设计优雅度的评审，很难找出代码业务逻辑的问题。让代码正确的反应设计，是当时评审过程中碰到的一个更大的问题。

1.2 代码质量很难有效提升

在承担架构师之前，我的另一个职责是技术管理，做的工作是与软件质量相关的。当时加入一个大概2000万规模的项目，有大约100开发人员参与，开发周期大概1年。加入该团队在开发的过程中，发现了两个问题：

- 每一个BA（可以理解为PD）设计的产品界面操作习惯都不一样，所有的开发人员做出来的界面的操作也完全不同。但是，这是一个面向物流行业的信息化软件，操作习惯的一致性很重要。
- 代码非常混乱，没有任何的规范可言，看代码简直想吐。

基于第一个问题，我定义了统一的界面规范，这个界面规范通过和公司的PMO合作将其融入到工程过程中，作为开发人员必须遵循的规范。第二个问题，我则花费了很多的时间来尝试解决（大概有2年时间都与代码质量做斗争），最终与寻找统一的设计方法殊途同归。

如何让我们的代码变得更加干净，我在执行的过程中，按照以下步骤一步一步的执行。

- 定义了统一的代码规范，基于界面规范的基础上，统一定义了模板工程，这些模板工程都有很好的代码基因。
- 定义了代码规范的培训教程，包括基本的书写规范、《代码整洁之道》、《重构技巧》。
- 定义了代码规范、代码评审制度，写入PMO定义的过程工作，作为开发人员遵循的制度。
- 通过代码评审提升质量太慢，为了大规模快速推广，引入了SonarQube，定义了软件代码质量的度量方法，软件的代码质量分数由：圈复杂度、重复率、代码规模问题、SonarQube扫描的问题数四个维度来衡量。在度量方法之上，定义了代码质量管理制度，每周扫描软件获得详细的代码质量报告，发送给相应的产品负责人，将代码质量管理制度也融入PMO的工程过程里面，全公司进行推广，由产品负责人负责本部分的代码质量提升。

基于以上的代码质量管理方法，我认为已经是做的相当不错，但是非常遗憾的是，当我抽样评审产品的代码时，我依然感到无比沮丧，软件的代码还是太复杂、太难看懂了，与《代码整洁之道》的要求相差太远了，我耗费了1年多的工作几乎毫无成果可言。因此，我在深深思考，在编码层面，定义了规范、做了优雅编码培训、定义了编写优秀代码的相关制度，就为了让开发人员把代码写好，使代码看起来更加清晰，软件更加容易维护，为什么还是无法实现？

2 软件复杂性的根源

贫血模型是软件复杂性的根源。贫血模型本质是面向数据的设计，面向过程的编码。基于贫血模型的分层架构，通常分为UI层、业务逻辑层、数据访问层、贫血模型层，贫血模型与数据模型一致。

业务规则是软件最核心的代码，通常只占整个软件很小的一部分。在基于贫血模型的架构中，业务规则的实现，通常混杂在上层UI展现逻辑、数据库访问、缓存等各种逻辑中，分散在各个层和关联对象。通过阅读业务逻辑层的代码来还原真实的业务规则很困难，很难从代码反映其业务规则设计，并且随着软件需求变更，业务规则更加难以还原，软件复杂度将不可控。

以下是一段业务逻辑层的实现代码。

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
public OrderDto signOrder(Order order) {
    Assert.notNull(order, "OrderDto can not be null.");
    OrderDto result = new OrderDto();
    result.setIsOperationSuccess(true);
    if (null == order.getId()) {
        result.setIsOperationSuccess(false);
        result.setOperationMassage("id不能为空。");
        return result;
    }
    OrderCondition orderCondition = new OrderCondition();
    orderCondition.setId(order.getId());
    order = orderMapper.selectOne(orderCondition);
    if (null == order) {
        result.setIsOperationSuccess(false);
        result.setOperationMassage("该订单不存在。");
        return result;
    }
    if (order.getOrderStatus() != Integer.valueOf(StatusEnum.ORDER_STATUS.ORDER_WAIT_RECEIVE.getCode())) {
        result.setIsOperationSuccess(false);
        result.setOperationMassage("订单号：{" + order.getOrderNo() + "}不是待收货状态，不能进行签收。");
        return result;
    }
    // 该订单下的所有商品的实收数(发货数量)必须都大于0
    boolean validDeliveryCount = true;
    Double orderTotalAmount = 0d;
    List<OrderGoodsDto> orderGoodsList = orderGoodsBiz.selectOrderGoodsByOrderId(order.getId());
    List<OrderGoods> orderGoodsListForUpdate = new ArrayList<>();
    if (EmptyUtil.isNotEmpty(orderGoodsList)) {
        for (OrderGoodsDto orderGoods : orderGoodsList) {
            if (null == orderGoods.getDeliveredNum() || orderGoods.getDeliveredNum() <= 0) {
                validDeliveryCount = false;
            } else {
                // 根据商品发货数量重新计算订单总金额......
                Double price = (null == orderGoods.getDiscountPrice() ? orderGoods.getOriginalPrice() : orderGoods.getDiscountPrice());
                Integer goodsNum = (null == orderGoods.getDeliveredNum() ? 0 : orderGoods.getDeliveredNum());
                orderTotalAmount += price * goodsNum;
                // 更新orderGoods的收货数量
                orderGoods.setReceivedNum(goodsNum);
                OrderGoods orderGoodsForUpdate = new OrderGoods();
                BeanUtils.copyProperties(orderGoods, orderGoodsForUpdate);
                orderGoodsListForUpdate.add(orderGoodsForUpdate);
            }
        }
    }
    if (!validDeliveryCount) {
        result.setIsOperationSuccess(false);
        result.setOperationMassage("订单号：" + order.getOrderNo() + "，订单下所有商品都已发货才可进行签收操作，请确认。");
        return result;
    }
    order.setOrderStatus(Integer.valueOf(StatusEnum.ORDER_STATUS.ORDER_SIGN.getCode()));
    order.setOrderTotalAmount(orderTotalAmount);
    order.setPaymentAmount(orderTotalAmount);
    order.setUnpaidAmount(orderTotalAmount);
    update(order);
    orderGoodsBiz.batchUpdate(orderGoodsListForUpdate);
    List<Order> orders = new ArrayList<Order>();
    orders.add(order);
    saveRouteMessage(orders);
    return result;
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

 

类似这样的代码非常常见，通过阅读这段业务逻辑代码，可以发现它处理了以下的任务：
（1）返回结果的处理。
（2）数据库访问。
（3）关联对象的数据库访问。
（4）业务规则。

业务规则代码与数据库访问、关联对象数据库访问、结果处理等其它逻辑在一起实现，通过代码还原业务规则会越来越复杂且随着时间推移，代码逻辑会越来越偏离设计。作为软件系统最核心的部分——业务规则，如果我们仅仅将其从其它任务中剥离，我们的代码将演化如下。（注：以下代码仅演示剥离出来业务逻辑，并非DDD推荐方式，下篇介绍。） 

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
public void signOrder(Order order) {
    assertCanBeSigned(order);

    Double orderTotalAmount = 0d;

    List<OrderGoods> orderGoodsList = order.getOrderGoods();
    for (OrderGoods orderGoods : orderGoodsList) {
        Double price = (null == orderGoods.getDiscountPrice() ? orderGoods.getOriginalPrice() : orderGoods.getDiscountPrice());
        Integer goodsNum = (null == orderGoods.getDeliveredNum() ? 0 : orderGoods.getDeliveredNum());
        orderTotalAmount += price * goodsNum;

        orderGoods.setReceivedNum(goodsNum);
    }

    order.setOrderStatus(Integer.valueOf(StatusEnum.ORDER_STATUS.ORDER_SIGN.getCode()));
    order.setOrderTotalAmount(orderTotalAmount);
    order.setPaymentAmount(orderTotalAmount);
    order.setUnpaidAmount(orderTotalAmount);
}

public void assertCanBeSigned(Order order) {
    Assert.notNull(order, "OrderDto can not be null.");

    if (order.getOrderStatus() != Integer.valueOf(StatusEnum.ORDER_STATUS.ORDER_WAIT_RECEIVE.getCode())) {
        throw new BusinessException("订单号：{" + order.getOrderNo() + "}不是待收货状态，不能进行签收。");
    }

    List<OrderGoods> orderGoodsList = order.getOrderGoods();
    if (!EmptyUtil.isNotEmpty(orderGoodsList)) {
        throw new BusinessException("订单号：" + order.getOrderNo() + "，订单没有包含商品，是一个空的订单，无法签收。");
    }

    for (OrderGoods orderGoods : orderGoodsList) {
        // 该订单下的所有商品的实收数(发货数量)必须都大于0
        if (null == orderGoods.getDeliveredNum() || orderGoods.getDeliveredNum() <= 0) {
            throw new BusinessException("订单号：" + order.getOrderNo() + "，订单下所有商品都已发货才可进行签收操作，请确认。");
        }
    }
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

 

这段代码反映的业务规则是订单签收规则。

（1）如果订单不是待发货状态，不能签收；
（2）校验订单下所有商品的发货数量都要大于0；
（3）计算订单总金额，并设置收货数量为发货数量；
（4）设置签收状态、总金额、支付金额和未付金额。

你可以发现这段单纯实现业务规则的代码，会更加的简单、清晰，也会使软件更加的容易维护。在DDD的方法论里面，业务规则是在领域层来实现的，领域层的代码仅仅是业务规则，这时候，其分层架构的分层逻辑和基于贫血模型的分层逻辑也会不一样了。

通过以上代码的对比我们发现：

- 剥离业务规则无关的代码，将更加清晰简单，容易和业务规则保持一致。
- 贫血模型会导致业务逻辑层混杂了太多代码和逻辑，难以还原业务规则，保证代码与设计一致性，是复杂性根源。

3 DDD如何解决软件复杂性

DDD解决软件复杂性的方法核心为两点：

- 通过领域模型为业务知识建模，领域模型作为业务、技术团队沟通的统一语言。
- 确保软件实现与领域模型保持一致。

软件实现与领域模型保持一致是本书的核心思想，DDD构建了一套完整的方法论来支持领域模型驱动程序设计。这套方法论简述如下。

- 分层架构：业务规则的代码只占软件很少的代码却是最核心的部分代码，将其分离出来作为独立的领域层，使领域层的实现与领域模型保持一致，领域层的业务对象不再是贫血模型。
- 领域驱动设计：领域驱动设计，即领域模型驱动程序设计。这里给出了如何通过代码表达领域模型的编码模式。这些模式包括：关联、实体、值对象、服务、聚合根、Repository、Factory。它们构建了将领域模型表达成代码的方法论，保证了代码和设计一致。
- 战略设计：复杂领域模型的实现方法论。

我将在下一篇文章中详细解释DDD的核心思想，让你明白它是如何解决复杂性的。

# [解构领域驱动设计（二）：分层架构](https://www.cnblogs.com/baihmpgy/p/10259297.html)

反映业务规则的代码是整个软件的核心，但是它一般只占很小的一部分，在传统的基于贫血模型的分层软件架构中，业务规则可能分散到各个层、各个代码段，从而使得通过代码来还原业务规则或者保证代码与业务规则一致将变得非常困难。DDD分层架构的核心思想就是将所有业务规则的代码抽取到领域层，保证领域层的编码与领域模型是完全一致的。

下图是DDD的分层架构。
￼![img](https://img2018.cnblogs.com/blog/21322/201901/21322-20190112122418328-535419692.png)

 

**一定要牢记：**DDD分层架构一个核心任务，就是将软件最重要的资产——业务规则分离出来，抽象在领域层，并确保这些代码是领域模型的正确实现。关于领域模型的实现，在下一篇文章介绍。 


接下来，我将通过代码来演示这个新的分层架构。

1 应用层

应用层在这里非常的简单清晰，它仅仅是将基础设施层、领域层提供的功能装配起来完成任务，这一层的代码逻辑非常简单。

下面是创建设计师订单的装配任务。

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
 1 @Service
 2 @Transactional(rollbackFor = Exception.class)
 3 public class DesignerOrderServiceImpl implements DesignerOrderService {
 4     @Autowired
 5     private DesignerOrderRepository designerOrderRepository;
 6     @Autowired
 7     private RefundOrderRepository refundOrderRepository;
 8 
 9     @Override
10     public DesignerOrder createOrder(int customerId, int designerId) {
11         DesignerOrder order = DesignerOrderFactory.createOrder(customerId, designerId);
12 
13         designerOrderRepository.create(order);
14 
15         return designerOrderRepository.selectByKey(order.getId());
16     }
17 
18     @Override
19     public void pay(int orderId, float amount) {
20         DesignerOrder order = designerOrderRepository.selectByKey(orderId);
21         if (order == null) {
22             AppException.throwAppException(AppExceptionMessage.DESIGNER_ORDER_NOT_EXIST_CODE, AppExceptionMessage.DESIGNER_ORDER_NOT_EXIST, orderId);
23         }
24 
25         order.pay(amount);
26         designerOrderRepository.update(order);
27     }
28 
29     @Override
30     public RefundOrder refund(int orderId, String cause) {
31         DesignerOrder order = designerOrderRepository.selectByKey(orderId);
32         if (order == null) {
33             AppException.throwAppException(AppExceptionMessage.DESIGNER_ORDER_NOT_EXIST_CODE, AppExceptionMessage.DESIGNER_ORDER_NOT_EXIST, orderId);
34         }
35 
36         RefundOrder refundOrder = order.refund(cause);
37 
38         designerOrderRepository.update(order);
39 
40         refundOrderRepository.create(refundOrder);
41 
42         return refundOrderRepository.selectByKey(refundOrder.getId());
43     }
44 }
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

 

这里例举了创建订单、付款、退款的应用层代码。

这里，订单创建有2个步骤：

（1）使用Factory创建新的业务对象；

（2）使用Repository将业务对象持久化到数据库。

付款3个步骤：

（1）使用Repository加载订单业务对象到内存；

（2）调用订单业务对象的付款方法更改业务对象状态；

（3）使用Repository将业务对象持久化到数据库。

退款有3个步骤：

（1）使用Repository加载订单业务对象到内存；

（2）调用设计师订单业务对象的退款方法改变业务对象的状态，然后生成一个退款订单业务对象；

（3）使用Repository持久化设计师订单和退款订单业务对象。

 

此外，应用层还额外处理了数据持久化的事务。

2 领域层

领域层是实现所有业务规则的领域对象，它是整个软件的核心，并且与领域模型保持一致。

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
 1 @Data
 2 @EqualsAndHashCode(of = {"id"})
 3 public class DesignerOrder implements Entity<DesignerOrder> {
 4     private int id;
 5     private DesignerOrderState state;
 6     private int customerId;
 7     private int designerId;
 8     private float area;
 9 
10     private float expectedAmount;
11     private int estimatedDays;
12     private DesigningProgressReport progressReport;
13 
14     private String abortCause;
15 
16     private float actualPaidAmount;
17 
18     private int feedbackStar;
19     private String feedbackDescription;
20 
21     private Date createdTime;
22     private Date updatedTime;
23 
24     public void pay(float amount) {
25         Assert.isTrue(amount > 0, "The amount must be bigger than 0.");
26 
27         if (!DesignerOrderWorkflowService.canChangeState(state, DesignerOrderState.PAID)) {
28             DomainException.throwDomainException(DomainExceptionMessage.PAYMENT_NOT_IN_READY_STATE_CODE, DomainExceptionMessage.PAYMENT_NOT_IN_READY_STATE, this.id, this.state);
29         }
30 
31         if (Math.abs(amount - this.expectedAmount) > 0.01) {
32             DomainException.throwDomainException(DomainExceptionMessage.PAYMENT_NOT_MATCHED_CODE, DomainExceptionMessage.PAYMENT_NOT_MATCHED, this.id, this.expectedAmount, amount);
33         }
34 
35         this.state = DesignerOrderWorkflowService.changeState(this.id, state, DesignerOrderState.PAID);
36         this.actualPaidAmount = amount;
37 
38         // 付款完成后，自动启动进度跟踪
39         this.progressReport.startup();
40     }
41 
42     public RefundOrder refund(String cause) {
43         this.assertCanRefund();
44 
45         this.state = DesignerOrderWorkflowService.changeState(this.id, state, DesignerOrderState.REFUND);
46 
47         return RefundOrderFactory.newRefundOrder(this, cause);
48     }
49 
50     private void assertCanRefund() {
51         DesigningProgressNode constructionDrawingDesignNode = this.progressReport.getNode(DesigningProgressNodeType.CONSTRUCTION_DRAWING_DESIGN);
52         if (constructionDrawingDesignNode.getState() == DesigningProgressNodeState.REQUEST_COMPLETION ||
53                 constructionDrawingDesignNode.getState() == DesigningProgressNodeState.CONFIRM_COMPLETION) {
54             DomainException.throwDomainException(DomainExceptionMessage.FAILED_TO_REFUND_FOR_PROGRESS_CODE, DomainExceptionMessage.FAILED_TO_REFUND_FOR_PROGRESS, this.id);
55         }
56     }
57 
58     @Override
59     public boolean sameIdentityAs(DesignerOrder other) {
60         return this.equals(other);
61     }
62 }
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

 

你可以发现业务对象的代码有：

- 业务对象内部状态，即它包含的属性（字段）。
- 业务对象方法，即业务规则的实现，业务对象方法一般完成业务对象状态变更。
- 业务对象关联，包含关联业务对象的属性或者字段。

关于领域层的编码模式，在下文会详细介绍。

3 基础设施层

基础设施层为上层提供通用的技术能力，包括消息传递、缓存、远程调用、分布式事务、持久化、UI绘制等。以下是持久化实现的一段代码。它以整个实体作为存储单元（注意：准确的说，是以聚合根为存储单元，后续详细介绍）。

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
 1 @Repository
 2 public class DesignerOrderRepositoryImpl implements DesignerOrderRepository {
 3     private static final String DESIGNER_ORDER_TABLE = "designer_order";
 4 
 5     @Autowired
 6     private DesignerOrderMapper designerOrderMapper;
 7 
 8     @Override
 9     public void create(DesignerOrder order) {
10         if (designerOrderMapper.create(order) == 0) {
11             TableException.throwTableException(DESIGNER_ORDER_TABLE, TableOperation.CREATE);
12         }
13     }
14 
15     @Override
16     public DesignerOrder selectByKey(int id) {
17         DesignerOrder order = designerOrderMapper.selectByKey(id);
18         buildConnection(order);
19         return order;
20     }
21 
22     @Override
23     public DesignerOrder selectOneBySpecification(DesignerOrder example) {
24         DesignerOrder designerOrder = designerOrderMapper.selectOneBySpecification(example);
25         buildConnection(designerOrder);
26         return designerOrder;
27     }
28 
29     @Override
30     public List<DesignerOrder> selectBySpecification(DesignerOrder example) {
31         List<DesignerOrder> designerOrders = designerOrderMapper.selectBySpecification(example);
32         buildConnection(designerOrders);
33         return designerOrders;
34     }
35 
36     @Override
37     public void update(DesignerOrder order) {
38         if (designerOrderMapper.update(order) == 0) {
39             TableException.throwTableException(DESIGNER_ORDER_TABLE, TableOperation.UPDATE);
40         }
41     }
42 }
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

 

4 结论

 

**一定要牢记：**DDD分层架构一个核心任务，就是将软件最重要的资产——业务规则分离出来，抽象在领域层，确保这些代码是领域模型的正确实现。 

 

通过以上的分层示例，我们可以总结出来领域驱动设计的代码基本模式：

1. 上层应用层通过Factory、Repository、领域对象协同来完成用户任务。
2. 通过Factory、Repository来处理领域对象生命周期管理，包括领域对象创建、加载、持久化。
3. 领域对象由状态和对状态变更的操作组成，它是业务规则的实现。在这里，字段代表状态，方法代表状态变更。领域对象状态变更后，由Repository进行持久化。如何涉及多个领域对象状态变更的一致性，则这几个领域对象的状态变更将组合在一起，由Repository进行一致性变更。
4. 基本模式：新建——通过Factory创建领域对象，调用领域对象方法更改状态，使用Repository将领域对象持久化；变更——通过Repository加载领域对象，调用领域对象方法更改状态，使用Repository将领域对象持久化。

￼![img](https://img2018.cnblogs.com/blog/21322/201901/21322-20190112123038855-1648242821.png)

 [解构领域驱动设计（三）：领域驱动设计](https://www.cnblogs.com/baihmpgy/p/10760324.html)

在上一部分，分层架构的目的是为了将业务规则剥离出来在单独的领域层中进行实现。再回顾一下领域驱动设计的分层中应用层代码的实现。

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
@Override
public void pay(int orderId, float amount) {
    DesignerOrder order = designerOrderRepository.selectByKey(orderId);   // 领域对象的加载
    if (order == null) {
        AppException.throwAppException(AppExceptionMessage.DESIGNER_ORDER_NOT_EXIST_CODE, AppExceptionMessage.DESIGNER_ORDER_NOT_EXIST, orderId);
    }
    
    order.pay(amount);    // 领域对象业务规则实现
    designerOrderRepository.update(order);    // 领域对象状态持久化
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

 

所有的业务规则都抽象到领域对象，比如“order.pay(amount)”抽象了付款的业务规则。领域对象由状态（对象的字段、属性）和操作（对象的方法）构成，领域对象的操作用于实现业务规则，业务规则执行完成后更改领域对象的状态。领域对象的持久化交给了基础设施层，这里，Repository目的是持久化领域对象状态。

领域驱动设计，即领域模型驱动程序设计，它的核心是保证系统的实现与实际的业务规则一致，完整实现了领域模型。它包含了两个部分：领域模型、领域模型的编程实现。

在软件设计和实现过程中要充分利用领域模型，设计过程中，领域模型作为与业务专家的沟通语言；实现过程中，领域模型作为与开发人员沟通的语言。领域模型在软件生命周期过程作为通用语言。

1 领域模型

领域建模（这里不重点介绍如何建模）方法论产出领域模型。我们可以使用UML建模，使用最简单、最容易理解的名词-形容词-动词法对领域知识进行建模，使用该模型作为与业务、技术团队沟通的通用语言。

在名词-形容词-动词法建模方法中，领域知识中的名词一般对应模型、形容词对应模型属性、动词对应模型方法。模型之间的关系有：组合、聚合、关联、依赖，四者关系由强到弱。

依赖(Dependency)关系是类与类之间的联接。依赖关系表示一个类依赖于另一个类的定义。一般而言，依赖关系在Java语言中体现为局域变量、方法的形参，或者对静态方法的调用。 

关联(Association）关系是类与类之间的联接，它使一个类知道另一个类的属性和方法。关联可以是双向的，也可以是单向的。在Java语言中，关联关系一般使用成员变量来实现。 

聚合(Aggregation) 关系是关联关系的一种，是强的关联关系。聚合是整体和个体之间的关系。例如，汽车类与引擎类、轮胎类，以及其它的零件类之间的关系便整体和个体的关系。与关联关系一样，聚合关系也是通过实例变量实现的。但是关联关系所涉及的两个类是处在同一层次上的，而在聚合关系中，两个类是处在不平等层次上的，一个代表整体，另一个代表部分。 

组合(Composition) 关系是关联关系的一种，是比聚合关系强的关系。它要求普通的聚合关系中代表整体的对象负责代表部分对象的生命周期，组合关系是不能共享的。代表整体的对象需要负责保持部分对象和存活，在一些情况下将负责代表部分的对象湮灭掉。代表整体的对象可以将代表部分的对象传递给另一个对象，由后者负责此对象的生命周期。换言之，代表部分的对象在每一个时刻只能与一个对象发生组合关系，由后者排他地负责生命周期。部分和整体的生命周期一样。 

简而言之，组合关系表示部分与整体关系，部分不能单独存在；聚合关系表示稍弱的部分与整体关系，部分可以单独存在；关联关系是一个模型和另一个模型的联接，比如一个订单有一个顾客而一个顾客有多个订单；依赖是最弱的关系，表示一个模型的实现使用到另一个模型的功能。

举个例子，我们与业务专家沟通，梳理了如下业务知识，然后我们使用名词-形容词-动词法来进行建模。

=====================
领域知识：装修设计预约平台
1 客户通过系统预约设计师进行装修设计，客户只能预约一个设计师订单，不能预约多个同时进行设计。
2 预约后，设计师上门进行量房，根据面积进行报价和预估设计时间。设计师订单按照4个节点预估交付时间，在不同节点交付不同成果，这四个节点分别为平面图、效果图、施工
图、交底，四个节点的付款比率分别为10%、40%、40%、10%。
3 客户接受报价方案后，进行付款，设计师开始设计；如果拒绝，则设计师可以进行再次报价和预估设计时间。
4 客户在付款之前，都可以进行终止。
5 客户付款后，正式进入设计阶段。设计师按阶段推进设计并按阶段更新进度。在每一个阶段，设计师完成任务后，客户进行阶段成果确认，客户确定后所有阶段后，订单自动完成。
6 客户可以对完成的订单进行评价。
7 客户对已付款但未完成的订单可以提出退款申请，退款计算方法依据当前设计进度，如果当前进度已经达到设计师请求施工图设计确认进度或超过该进度，则不允许退款。如果允许退款，退款金额最多为（总额 - 已完成的各阶段付款之和），最少为未完成交付节点的待付款总额。
8 申请通过的退款订单不再允许更新进度。
=====================

在这里我们可以梳理出来的名词有：客户、设计师订单、设计师、订单交付进度与交付节点、退款订单。
和设计师订单有关的动词有：量房、报价、接受（拒绝）报价、取消、付款、确认进度、退款、评价等。
设计师订单有关的属性有：订单金额、支付金额、面积、取消原因、评价、状态等。

因此，我们通过使用名词-形容词-动词法构建的模型图如下所示。

![img](https://img2018.cnblogs.com/blog/21322/201904/21322-20190424081729431-1989460774.png)

这里，模型有：客户Customer，设计师Designer，设计师订单DesignerOrder，退款单RefundOrder，设计进度DesigningProgressReport，设计进度节点DesigningProgressNode。模型中组合关系为：设计进度DesigningProgressReport，设计进度节点DesigningProgressNode；其它模型之间的关系为关联关系。

这个模型就作为软件开发和维护过程的通用语言。接下来，我们将介绍如何来实现领域模型。

2 领域模型实现

在上一节，我们介绍了通过领域建模来构建了领域模型。接下来我们要介绍如何实现模型驱动程序设计，即我们如何通过代码来实现领域模型对应的业务逻辑。领域模型的实现代码在领域层，它完整实现了领域模型的内部结构和模型之间的关系。

领域模型的实现代码由以下几个部分构成：
• 领域模型关系的实现：组合、聚合、关联、依赖。
• 领域模型的实现：实体和值对象。
• 跨领域模型的业务规则的实现：领域服务。

2.1 领域模型关系的实现

聚合、组合、关联关系在实现上的表现基本上是一个类（或者类的标识）作为另一个类的属性；而依赖关系则是一个类作为另一个类在方法的实现上的参数、变量，为另一个类提供功能实现。

下面我们简单看一下如何通过编码来实现类关联关系，比如在模型上客户和设计师订单是关联关系，一个客户可以有多个设计师订单，但是每一个设计师订单只能有一个客户和一个设计师并且最多只有一个退款订单。

（1）聚合、组合、关联
表现在一个类持有另一个类的引用，引用可以是实例的引用或者标识的引用，具体实现为属性。这种关系是双向关系，为了简化编码，可能只需要一方持有另一方的引用即可，这依赖于具体要实现的业务逻辑。如下代码实现了DesignerOrder对设计师、进度报告的关系。

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
public class DesignerOrder implements Entity<DesignerOrder> {
    private int id;
    private int designerId;

    private DesigningProgressReport progressReport;
    ……

    public Designer getDesigner() {
        return designerRepository.getDesignerById(this.designerId);
    }

    public DesigningProgressReport getProgressReport() {
        return this.progressReport; 
    }

    ……
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

 

（2）依赖
依赖表现在一个类的实现使用到另一个类的功能，依赖的类可能作为方法的参数、方法局部变量或者静态引用等。如下代码体现了对DesignerOrderWorkflowService的功能依赖。

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
public class DesignerOrder implements Entity<DesignerOrder> {
    public void pay(float amount) {
        Assert.isTrue(amount > 0, "The amount must be bigger than 0.");

        if (!DesignerOrderWorkflowService.canChangeState(state, DesignerOrderState.PAID)) {
            BusinessException.throwException(DomainExceptionMessage.PAYMENT_NOT_IN_READY_STATE_CODE, DomainExceptionMessage.PAYMENT_NOT_IN_READY_STATE, this.id, this.state);
        }

        if (Math.abs(amount - this.expectedAmount) > 0.01) {
            BusinessException.throwException(DomainExceptionMessage.PAYMENT_NOT_MATCHED_CODE, DomainExceptionMessage.PAYMENT_NOT_MATCHED, this.id, this.expectedAmount, amount);
        }

        this.state = DesignerOrderWorkflowService.changeState(this.id, state, DesignerOrderState.PAID);
        this.actualPaidAmount = amount;

        // 付款完成后，自动启动进度跟踪
        this.progressReport.startup();
    }
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

 

2.2 领域模型的实现

领域模型在实现上表现为两类：（1）实体（Entity）：这个领域模型有特定的标识，但是其内部状态会随着一序列的事件（对应业务规则的执行）发生变化，我们把这类模型的实现称为实体；（2）值对象（Value Object）：这个领域模型由属性来定义，实例创建后不会发生变更，变更也意味着重新创建一个实例，我们把这类模型的实现称为值对象。

（1）实体
在装修设计预约平台的领域模型里面，我们很容易可以发现设计师订单就是一个实体，在创建后，每一个设计师订单有一个唯一的订单号，后续有量房、报价、付款、退款等系列动作的发生，从而订单的内部状态（字段值）会发生变化，但是都代表的是同一个订单。每一个实体的实现都有一个标识。如下所示，这里的id字段表示了订单的唯一标识，并实现了Entity接口，Entity接口sameIdentityAs方法，判断实体的Id是否相同。

实体的属性和操作，对应着模型的状态和状态的变更，他们与模型的定义使一致的。

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
@Data
@EqualsAndHashCode(of = {"id"})
public class DesignerOrder implements Entity<DesignerOrder> {
    private int id;
    private DesignerOrderState state;
    private int customerId;
    private int designerId;
    private float area;

    private float expectedAmount;
    private int estimatedDays;
    private DesigningProgressReport progressReport;

    private String abortCause;

    private float actualPaidAmount;

    private int feedbackStar;
    private String feedbackDescription;

    private Date createdTime;
    private Date updatedTime;

    @Override
    public boolean sameIdentityAs(DesignerOrder other) {
        return this.equals(other);
    }

    public void measure(float area) {
        Assert.isTrue(area > 0, "The area must be bigger than 0.");

        this.state = DesignerOrderWorkflowService.changeState(this.id, state, DesignerOrderState.MEASURED);
        this.area = area;
    }

    public void quote(float amount, int[] estimatedDaysList) {
        Assert.isTrue(amount > 0, "The price must be bigger than 0.");
        this.assertEstimatedDaysList(estimatedDaysList);

        this.state = DesignerOrderWorkflowService.changeState(this.id, state, DesignerOrderState.QUOTED);
        this.expectedAmount = amount;
        this.progressReport = DesigningProgressReportFactory.newReport(this, estimatedDaysList);
        this.estimatedDays = this.progressReport.getEstimatedCompletionDays();
    }

    private void assertEstimatedDaysList(int[] estimatedDaysList) {
        if (null == estimatedDaysList || estimatedDaysList.length != 4) {
            throw new IllegalArgumentException("The size of estimatedDaysList must be 4.");
        }

        for (int days : estimatedDaysList) {
            if (days <= 0) {
                throw new IllegalArgumentException("Each element of estimatedDaysList must be bigger than 0.");
            }
        }
    }

    public void pay(float amount) {
        Assert.isTrue(amount > 0, "The amount must be bigger than 0.");

        if (!DesignerOrderWorkflowService.canChangeState(state, DesignerOrderState.PAID)) {
            BusinessException.throwException(DomainExceptionMessage.PAYMENT_NOT_IN_READY_STATE_CODE, DomainExceptionMessage.PAYMENT_NOT_IN_READY_STATE, this.id, this.state);
        }

        if (Math.abs(amount - this.expectedAmount) > 0.01) {
            BusinessException.throwException(DomainExceptionMessage.PAYMENT_NOT_MATCHED_CODE, DomainExceptionMessage.PAYMENT_NOT_MATCHED, this.id, this.expectedAmount, amount);
        }

        this.state = DesignerOrderWorkflowService.changeState(this.id, state, DesignerOrderState.PAID);
        this.actualPaidAmount = amount;

        // 付款完成后，自动启动进度跟踪
        this.progressReport.startup();
    }

    public RefundOrder refund(String cause) {
        this.assertCanRefund();

        this.state = DesignerOrderWorkflowService.changeState(this.id, state, DesignerOrderState.REFUND);

        return RefundOrderFactory.newRefundOrder(this, cause);
    }
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

 

DDD对于实体有一段重要描述：当一个对象由其标识而不是属性区分时，那么在模型中应该主要通过标识来确定该对象的定义。使类定义变得简单，并集中关注生命周期的连续性和标识。定义一种区分每个对象的方式，这种方式应该与其形式和历史无关。要格外注意那些需要通过属性来匹配对象的需求。在定义标识操作时，要确保这种操作作为每个对象生成唯一的结果，这可以通过附加一个保证唯一性的符号来实现。这种定义标识的方法可能来自外部，也可能是由系统创建的任意标识符，但它在模型中必须是唯一的标识。模型必须定义出“符合什么条件才算是相同的事务”。

（2）值对象
在货物运输系统中，当我们为一个货物的运输执行一条路线之后，那么这条路线不能发生变更，我们倾向于把路由线路看做一个值对象。如下图所示。对于值对象，通过属性值即可标识。

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
public class RouteSpecification extends AbstractSpecification<Itinerary> implements ValueObject<RouteSpecification> {

  private Location origin;
  private Location destination;
  private Date arrivalDeadline;

  public RouteSpecification(final Location origin, final Location destination, final Date arrivalDeadline) {
    Validate.notNull(origin, "Origin is required");
    Validate.notNull(destination, "Destination is required");
    Validate.notNull(arrivalDeadline, "Arrival deadline is required");
    Validate.isTrue(!origin.sameIdentityAs(destination), "Origin and destination can't be the same: " + origin);

    this.origin = origin;
    this.destination = destination;
    this.arrivalDeadline = (Date) arrivalDeadline.clone();
  }

  public Location origin() {
    return origin;
  }

  public Location destination() {
    return destination;
  }

  public Date arrivalDeadline() {
    return new Date(arrivalDeadline.getTime());
  }

  @Override
  public boolean isSatisfiedBy(final Itinerary itinerary) {
    return itinerary != null &&
           origin().sameIdentityAs(itinerary.initialDepartureLocation()) &&
           destination().sameIdentityAs(itinerary.finalArrivalLocation()) &&
           arrivalDeadline().after(itinerary.finalArrivalDate());
  }

  @Override
  public boolean sameValueAs(final RouteSpecification other) {
    return other != null && new EqualsBuilder().
      append(this.origin, other.origin).
      append(this.destination, other.destination).
      append(this.arrivalDeadline, other.arrivalDeadline).
      isEquals();
  }

  @Override
  public boolean equals(final Object o) {
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;

    final RouteSpecification that = (RouteSpecification) o;

    return sameValueAs(that);
  }

  @Override
  public int hashCode() {
    return new HashCodeBuilder().
      append(this.origin).
      append(this.destination).
      append(this.arrivalDeadline).
      toHashCode();
  }
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

 

值对象（Value Object）所包含的属性应该行程一个概念整体。当我们只关心一个模型元素的属性时，应该把它归类为Value Object。我们应该使这个模型元素能够表示出其属性的意义，并为它提供相关功能。Value Object应该是不可变的。不要为它分配粉盒标识，而且不要把它设计成像Entity那么复杂。

2.3 跨领域模型的业务规则的实现

我们使用领域服务来封装不属于领域模型或者领域模型公共的业务规则。领域服务的方法一般是静态的，并且不会更改内部状态。在装修设计预约平台里面，我们使用状态机工作流服务实现订单状态流转，它可以在设计师订单和退款单中共用。在《领域驱动设计》里面有一个示例，展示了转账服务的实现，转账动作实现的是从一个账户到另一个账户的资金流转，因此将转账设计到领域服务TransferService里面。关于服务的描述是：当领域中的某个重要的过程或转换操作不属于实体或值对象的自然职责时，应该在模型中添加一个作为独立接口的操作，并将其声明为Service。定义接口时要使用模型语言，并确保操作名称是领域模型的术语。此外，应该将Service定义为无状态的。

以下是服务示例。

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
public class DesignerOrderWorkflowService {
    private DesignerOrderWorkflowService() { }

    private static Map<DesignerOrderState, DesignerOrderState[]> states = new HashMap<>();
    static {
        states.put(DesignerOrderState.NEW, new DesignerOrderState[]{ DesignerOrderState.MEASURED, DesignerOrderState.ABORTED });
        states.put(DesignerOrderState.MEASURED, new DesignerOrderState[]{ DesignerOrderState.QUOTED, DesignerOrderState.ABORTED });
        states.put(DesignerOrderState.QUOTED, new DesignerOrderState[]{ DesignerOrderState.ACCEPT_QUOTE, DesignerOrderState.REJECT_QUOTE, DesignerOrderState.ABORTED });
        states.put(DesignerOrderState.REJECT_QUOTE, new DesignerOrderState[]{ DesignerOrderState.QUOTED, DesignerOrderState.ABORTED });
        states.put(DesignerOrderState.ACCEPT_QUOTE, new DesignerOrderState[]{ DesignerOrderState.PAID, DesignerOrderState.ABORTED });
        states.put(DesignerOrderState.PAID, new DesignerOrderState[]{ DesignerOrderState.REFUND, DesignerOrderState.COMPLETION });
        states.put(DesignerOrderState.COMPLETION, new DesignerOrderState[]{ DesignerOrderState.FEEDBACK });

        states.put(DesignerOrderState.ABORTED, new DesignerOrderState[]{ DesignerOrderState.FEEDBACK });
        states.put(DesignerOrderState.REFUND, new DesignerOrderState[]{ DesignerOrderState.FEEDBACK });
        states.put(DesignerOrderState.FEEDBACK, new DesignerOrderState[]{ DesignerOrderState.FEEDBACK }); // 允许多次评价
    }

    public static boolean canChangeState(DesignerOrderState state, DesignerOrderState nextState) {
        Assert.notNull(state, "The state can not be null.");
        Assert.notNull(nextState, "The nextState can not be null.");

        DesignerOrderState[] nextStates = states.get(state);
        for (DesignerOrderState possibleNextState : nextStates) {
            if (possibleNextState.equals(nextState)) {
                return true;
            }
        }

        return false;
    }

    public static boolean canAbort(DesignerOrder order) {
        return canChangeState(order.getState(), DesignerOrderState.ABORTED);
    }

    public static DesignerOrderState changeState(long orderId, DesignerOrderState state, DesignerOrderState nextState) {
        if (!canChangeState(state, nextState)) {
            BusinessException.throwException(DomainExceptionMessage.STATE_CHANGE_ILLEGAL_CODE, DomainExceptionMessage.STATE_CHANGE_ILLEGAL, orderId, state, nextState);
        }

        return nextState;
    }

    public static boolean isCompleted(DesignerOrder order) {
        return order.getState() == DesignerOrderState.ABORTED ||
                order.getState() == DesignerOrderState.REFUND ||
                order.getState() == DesignerOrderState.COMPLETION ||
                order.getState() == DesignerOrderState.FEEDBACK;
    }
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

 

3 领域模型生命周期管理

领域模型的创建会包含业务规则，我们应该将这些业务规则封装起来，使创建过程对应用层透明，这里引入Factory来实现创建。此外，对于实体，发生一系列事件后，其内部状态发生了变更，这些状态变更需要持久化，以使得应用程序能够恢复实体状态。对于值对象，我们可能也需要持久化相应的属性。这里，我们引入Repository来实现持久化管理。对于一些关联很紧密的对象，比如采购订单和商品，他们需要共同的满足一个规则（比如采购订单里面的商品的总额不能超过采购订单的限额），如果多个用户同时变更采购订单或者其包含的商品，就需要引入很复杂的锁。为了使关联紧密的对象在整个生命周期都保持一致性，我们引入了聚合Aggregate，通过它来实现一致性。

![img](https://img2018.cnblogs.com/blog/21322/201904/21322-20190424082042676-538079745.png) 

 

**总结一句话：**创建阶段——Factory用于封装实现领域对象创建的业务规则；创建、修改——Aggregate用于封装紧密关联领域对象在生命周期内的数据一致性；存储——Repository用于封装领域对象持久化的逻辑。

 

3.1 紧密关联的领域对象的一致性维护—Aggregate

首先，我们先看一下为什么要引入Aggregate。这里以采购订单为例子，采购员创建采购订单时需要指定限额，然后增加采购项目，因此可能存在两个采购员对同一个创建的采购订单进行操作，来更改订单。

![img](https://img2018.cnblogs.com/blog/21322/201904/21322-20190424082109559-2086080174.png)

如下所示，对于采购订单0012946，当前的商品金额为700，限额为1000。采购员A可能更改商品项1的数量为5，其总额为900，满足限额；采购员B可能更改商品项2的数量为3，其总额也为900，满足限额。

![img](https://img2018.cnblogs.com/blog/21322/201904/21322-20190424082118700-826334107.png)

当采购员A、B同时提交更新后，采购订单的总额为1100，超过了1000元限额，破坏了业务规则。

在传统的方法，当我们采用以下方式更新采购订单商品，就会出现刚才破坏业务规则的情况发生。

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
PurchaseOrder purchaseOrder = purchaseOrderBiz.getByKey(“0012946”);

List<PurchaseOrderItem> purchaseOrderItems = purchaseOrderItemBiz.getByOrderId(“0012946”);
changePurchaseOrderItems(purchaseOrderItems);
if (new PurchaseOrderApprovedLimitSpecify(purchaseOrderItems, purchaseOrder).isSatisfied()) {
    purchaseOrderItemBiz.updateBatch(purchaseOrderItems);
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

 

为了避免发生采购订单限额的业务规则被破坏，对采购订单项的变更，需要对采购订单加排它锁。

在DDD里面，引入了聚合（Aggregate）来解决这个问题。Aggregate时一组相关对象的集合，作为数据修改的单元，在整个生命周期中满足固定的业务规则。每个Aggregate都有一个根（root）和一个边界（boundary）。边界定义了Aggregate的内部都有什么，根则是Aggregate中所包含的一个特定Entity。在Aggregate中，根是唯一允许外部对象保持对它的引用的元素，而边界内部的对象则可以互相引用。基于聚合，我们来实现一致的采购订单业务规则如下。

（1）应用层通过以下方式来更新聚合根里面的内容，这里必须满足一致性规则：对聚合内部实体的状态变更，只能通过聚合根来实现，通过聚合根来维持业务一致性。

```
PurchaseOrder order = purchaseOrderRepository.load(id);
order.addItem(…)/removeItem(…)/updateItem(…); // 注意：这里是重点，对聚合根内部的变更，只能通过聚合根，不能通过获取内部对象进行操作
purchaseOrderRepository.save(order);
```

 

（2）聚合根对内部实体的状态变更如下。

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
public class PurchaseOrder {
    private PurchaseOrderItemRepository orderItemRepository;
    private List<PurchaseOrderItem> orderItems;
    // ……
    public void addItem(int itemId, int count) {
        PurchaseOrderItem orderItem = PurchaseOrderItemFactory.create(this, itemId, count);
        orderItems.add(orderItem);
        if (!new PurchaseOrderApprovedLimitSpecification(this).isSatisfied()) {
            BusinessException.throwException(…);
            return;
        }
        
        orderItemRepository.save(orderItem);
        this.updateTimestamp();
    }
    // ……
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

 

聚合根定义的规则如下：
• 根Entity具有全局标识，它最终负责检查固定规则。
• 根Entity具有全局标识。边界内的Entity具有本地标识，这些标识只有在Aggregate内部才是唯一的。
• Aggregate外部的对象不能引用除根Entity之外的任何内部对象。根Entity可以把对内部Entity的引用传递给它们，但这些对象只能临时使用这些引用，而不能保持引用。根可以把一个Value Object的副班传递给另一个对象，而不必关心它发生什么变化，因为它只是一个Value，不再与Aggregate有任何关联。
• 作为上一条规则的推论，只有Aggregate的根才能直接通过数据库查询获取。所有其他对象必须通过关联的遍历才能找到。
• Aggregate内部的对象可以保持对其他Aggregate根的引用。
• 删除操作必须一次删除Aggregate之内的所有对象。
• 当提交对Aggregate彬姐内部的任何对象的修改时，整个Aggregate中的所有固定规则都必须被满足。

3.2 领域模型的创建—Factory

当创建一个对象或创建整个Aggregate时，如果创建工作很负责，或者暴露了过多的内部结构，则可以使用Factory进行封装。领域模型的创建也可能隐含了业务规则，Factory可以向应用层屏蔽业务规则。以下是一个设计师订单的Factory类。

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
public class DesignerOrderFactory {
    private DesignerOrderFactory() {}

    public static DesignerOrder createOrder(int customerId, int designerId) {
        DesignerOrder designerOrder = new DesignerOrder();
        designerOrder.setCustomerId(customerId);
        designerOrder.setDesignerId(designerId);
        designerOrder.setState(DesignerOrderState.NEW);

        return designerOrder;
    }
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

 

结论：应该将创建复杂对象的实例和聚合的职责转移给一个单独的对象，这个对象本身在领域模型中可能没有职责，但它仍是领域设计的一部分。提供一个封装所有复杂装配操作的接口，而且这个接口应该不需要上层引用要被实例化的对象的具体类。在创建Aggregate时，要把它作为一个整体，并确保它满足固定规则。

3.3 领域模型的持久化—Repository

Repository的目的是实现领域对象的持久化，用于领域对象关联查询、重建、添加和删除。我们只为那些确实需要直接访问的Aggregate提供Repository，将所有对象的存储和访问操作交给Repository。如下是一个实例。

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
@Repository
public class DesignerOrderRepositoryImpl implements DesignerOrderRepository {
    private static final String DESIGNER_ORDER_TABLE = "designer_order";

    @Autowired
    private DesignerOrderMapper designerOrderMapper;

    @Override
    public void create(DesignerOrder order) {
        if (designerOrderMapper.create(order) == 0) {
            TableException.throwTableException(DESIGNER_ORDER_TABLE, TableOperation.CREATE);
        }
    }

    @Override
    public DesignerOrder selectByKey(int id) {
        DesignerOrder order = designerOrderMapper.selectByKey(id);
        buildConnection(order);
        return order;
    }

    @Override
    public DesignerOrder selectOneBySpecification(DesignerOrder example) {
        DesignerOrder designerOrder = designerOrderMapper.selectOneBySpecification(example);
        buildConnection(designerOrder);
        return designerOrder;
    }

    @Override
    public List<DesignerOrder> selectBySpecification(DesignerOrder example) {
        List<DesignerOrder> designerOrders = designerOrderMapper.selectBySpecification(example);
        buildConnection(designerOrders);
        return designerOrders;
    }

    @Override
    public void update(DesignerOrder order) {
        if (designerOrderMapper.update(order) == 0) {
            TableException.throwTableException(DESIGNER_ORDER_TABLE, TableOperation.UPDATE);
        }
    }
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

 

4 结论

领域驱动设计的模式如下所示。

 ![img](https://img2018.cnblogs.com/blog/21322/201904/21322-20190424082244912-1660520528.png)

综上，领域层的实现由聚合构成，每一个聚合通常包含了聚合根和领域模型实现、Service、工厂、Repository、领域异常等。

![img](https://img2018.cnblogs.com/blog/21322/201904/21322-20190424082256460-941614887.png)

最终装修设计预约平台的领域模型如下所示。

![img](https://img2018.cnblogs.com/blog/21322/201904/21322-20190424082306791-1799612384.png)

 

源码：https://github.com/lorry2018/ddd-simple-designer-order